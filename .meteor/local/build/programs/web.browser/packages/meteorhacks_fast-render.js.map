)]}'
{"version":3,"file":"/packages/meteorhacks:fast-render.js","sources":["meteorhacks:fast-render/lib/utils.js","meteorhacks:fast-render/lib/vendor/deepExtend.js","meteorhacks:fast-render/lib/client/log.js","meteorhacks:fast-render/lib/client/fast_render.js","meteorhacks:fast-render/lib/client/ddp_update.js","meteorhacks:fast-render/lib/client/data_handler.js","meteorhacks:fast-render/lib/client/iron_router_support.js","meteorhacks:fast-render/lib/client/auth.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,+B;AACA,2C;AACA,gC;AACA,E;;AAEA,sC;AACA,mD;AACA,6D;AACA,E;;;;;;;;;;;;;;;;;;;ACRA,8F;AACA,uC;AACA,gF;AACA,Y;AACA,gC;AACA,mB;AACA,2C;AACA,+C;AACA,kC;AACA,oC;AACA,mC;AACA,wC;AACA,oB;AACA,sC;AACA,oC;AACA,oC;AACA,wC;AACA,kC;AACA,gC;AACA,oC;AACA,mC;AACA,Q;AACA,gB;AACA,oC;AACA,gD;AACA,U;AACA,iC;AACA,wB;AACA,6C;AACA,U;AACA,kC;AACA,iD;AACA,U;AACA,mC;AACA,yD;AACA,U;AACA,8B;AACA,uF;AACA,U;AACA,uC;AACA,sE;AACA,wB;AACA,W;AACA,e;AACA,kI;AACA,0B;AACA,a;AACA,uB;AACA,wB;AACA,W;AACA,kB;AACA,6B;AACA,2D;AACA,S;AACA,Q;AACA,sC;AACA,oB;AACA,kC;AACA,Y;AACA,K;AACA,mE;AACA,iB;AACA,K;AACA,uB;AACA,oB;AACA,U;AACA,K;AACA,8B;AACA,6C;AACA,+B;AACA,6B;AACA,+B;AACA,gC;AACA,oB;AACA,W;AACA,qG;AACA,8B;AACA,kC;AACA,2D;AACA,oB;AACA,kE;AACA,a;AACA,iC;AACA,yD;AACA,0C;AACA,gC;AACA,W;AACA,S;AACA,O;AACA,K;AACA,kB;AACA,G;;;;;;;;;;;;;;;;;;AC3FA,mD;AACA,K;AACA,oC;AACA,0C;AACA,6C;AACA,sC;AACA,0C;AACA,G;AACA,C;;AAEA,yB;AACA,uC;AACA,E;;AAEA,0B;AACA,qC;AACA,E;;;;;;;;;;;;;;;;;;AChBA,gB;;AAEA,4D;AACA,wC;AACA,oC;AACA,iD;AACA,0F;AACA,G;;AAEA,gD;AACA,4D;AACA,K;AACA,E;;AAEA,gE;AACA,qB;;;;;;;;;;;;;;;;;;ACfA,gD;AACA,wB;AACA,S;AACA,C;;AAEA,mC;AACA,yB;;AAEA,oE;AACA,0D;AACA,0B;;;AAGA,sD;AACA,wE;AACA,0C;AACA,I;AACA,mE;AACA,yE;AACA,I;AACA,yE;AACA,0E;AACA,uC;AACA,I;AACA,6E;;AAEA,6D;AACA,yD;AACA,2E;AACA,yB;AACA,wD;AACA,uB;AACA,+D;AACA,8B;AACA,4B;AACA,O;AACA,K;AACA,G;;AAEA,8D;AACA,+B;;AAEA,oE;AACA,8C;AACA,gF;AACA,wC;AACA,yE;AACA,0B;AACA,4D;AACA,yD;AACA,kE;AACA,+D;;AAEA,mD;AACA,qD;AACA,wE;AACA,S;AACA,S;AACA,K;;AAEA,oD;AACA,yC;AACA,8D;AACA,qD;AACA,oC;AACA,K;AACA,G;;AAEA,8C;AACA,E;;AAEA,mD;AACA,iD;AACA,uB;;AAEA,+E;AACA,8C;AACA,uE;AACA,yD;AACA,wD;AACA,kC;AACA,wB;AACA,G;;AAEA,kB;;AAEA,8D;AACA,+B;AACA,0B;AACA,yB;AACA,2C;AACA,mD;;AAEA,0B;AACA,sC;AACA,oE;AACA,8C;AACA,gE;AACA,K;AACA,G;;;AAGA,sC;AACA,E;;;;;;;;;;;;;;;;;;;ACvGA,0C;AACA,qE;AACA,mC;AACA,iD;AACA,wD;;AAEA,wC;;AAEA,oC;AACA,gD;AACA,qD;AACA,yC;AACA,uC;AACA,8F;AACA,6B;AACA,6D;AACA,0B;AACA,+C;AACA,yD;AACA,kB;AACA,yC;AACA,W;AACA,gB;AACA,2F;AACA,S;AACA,S;AACA,O;AACA,G;AACA,C;;;;;;;;;;;;;;;;;;;AC5BA,mC;;AAEA,4C;AACA,yD;AACA,wD;AACA,0F;;AAEA,wD;AACA,kE;AACA,2D;AACA,uD;AACA,kB;AACA,0B;AACA,iD;AACA,6B;AACA,O;AACA,U;AACA,2B;AACA,G;AACA,E;;AAEA,yC;AACA,2C;AACA,iB;AACA,yB;AACA,mC;AACA,6B;AACA,8E;AACA,uF;AACA,+E;AACA,uD;AACA,kE;AACA,uD;AACA,yE;AACA,2D;;AAEA,iB;AACA,kD;AACA,6C;;AAEA,sF;AACA,Y;AACA,yB;AACA,oB;AACA,O;AACA,K;AACA,U;AACA,oD;AACA,G;AACA,E;;AAEA,mB;AACA,wC;AACA,2B;;AAEA,yB;AACA,sC;;AAEA,a;AACA,C;;;;;;;;;;;;;;;;;;;AC3DA,sC;AACA,8B;AACA,6B;AACA,iC;;AAEA,8D;AACA,4E;AACA,0B;AACA,gB;AACA,2E;AACA,mG;;AAEA,sD;AACA,oB;AACA,oC;AACA,W;AACA,c;AACA,sD;AACA,oB;AACA,qB;AACA,W;AACA,O;AACA,K;AACA,K;AACA,Q;AACA,sD;AACA,gD;AACA,c;AACA,e;AACA,K;AACA,C","sourcesContent":["EncodeEJSON = function(ejson) {\n  var ejsonString = EJSON.stringify(ejson);\n  return encodeURI(ejsonString);\n};\n\nDecodeEJSON = function(encodedEjson) {\n  var decodedEjsonString = decodeURI(encodedEjson);\n  return EJSON.fromJSONValue(JSON.parse(decodedEjsonString));\n};\n","// stolen from: http://stackoverflow.com/questions/9399365/deep-extend-like-jquerys-for-nodejs\nDeepExtend = deepExtend = function () {\n  var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},\n      i = 1,\n      length = arguments.length,\n      deep = false,\n      toString = Object.prototype.toString,\n      hasOwn = Object.prototype.hasOwnProperty,\n      push = Array.prototype.push,\n      slice = Array.prototype.slice,\n      trim = String.prototype.trim,\n      indexOf = Array.prototype.indexOf,\n      class2type = {\n        \"[object Boolean]\": \"boolean\",\n        \"[object Number]\": \"number\",\n        \"[object String]\": \"string\",\n        \"[object Function]\": \"function\",\n        \"[object Array]\": \"array\",\n        \"[object Date]\": \"date\",\n        \"[object RegExp]\": \"regexp\",\n        \"[object Object]\": \"object\"\n      },\n      jQuery = {\n        isFunction: function (obj) {\n          return jQuery.type(obj) === \"function\"\n        },\n        isArray: Array.isArray ||\n        function (obj) {\n          return jQuery.type(obj) === \"array\"\n        },\n        isWindow: function (obj) {\n          return obj != null && obj == obj.window\n        },\n        isNumeric: function (obj) {\n          return !isNaN(parseFloat(obj)) && isFinite(obj)\n        },\n        type: function (obj) {\n          return obj == null ? String(obj) : class2type[toString.call(obj)] || \"object\"\n        },\n        isPlainObject: function (obj) {\n          if (!obj || jQuery.type(obj) !== \"object\" || obj.nodeType) {\n            return false\n          }\n          try {\n            if (obj.constructor && !hasOwn.call(obj, \"constructor\") && !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n              return false\n            }\n          } catch (e) {\n            return false\n          }\n          var key;\n          for (key in obj) {}\n          return key === undefined || hasOwn.call(obj, key)\n        }\n      };\n    if (typeof target === \"boolean\") {\n      deep = target;\n      target = arguments[1] || {};\n      i = 2;\n    }\n    if (typeof target !== \"object\" && !jQuery.isFunction(target)) {\n      target = {}\n    }\n    if (length === i) {\n      target = this;\n      --i;\n    }\n    for (i; i < length; i++) {\n      if ((options = arguments[i]) != null) {\n        for (name in options) {\n          src = target[name];\n          copy = options[name];\n          if (target === copy) {\n            continue\n          }\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && jQuery.isArray(src) ? src : []\n            } else {\n              clone = src && jQuery.isPlainObject(src) ? src : {};\n            }\n            // WARNING: RECURSION\n            target[name] = deepExtend(deep, clone, copy);\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    }\n    return target;\n  }","Log = function function_name(message/*, args..*/) {\n  if(\n    typeof console != 'undefined' &&\n    typeof localStorage != 'undefined' && \n    localStorage.getItem('__frlog') == \"1\") {\n    arguments[0] = arguments[0] + \":\";\n    console.log.apply(console, arguments);\n  }\n}\n\nLog.enable = function() {\n  localStorage.setItem('__frlog', \"1\");\n};\n\nLog.disable = function() {\n  localStorage.removeItem('__frlog');\n};","FastRender = {};\n\nFastRender.completeSubscriptions = function(subscriptions) {\n  if(typeof subscriptions == 'string') {\n    subscriptions = [subscriptions];\n  } else if(subscriptions.constructor != Array) {\n    throw new Error('subscriptions params should be either a string or array of strings');\n  }\n\n  subscriptions.forEach(function(subscription) {\n    __fast_render_config.subscriptions[subscription] = true;\n  });\n};\n\nFastRender.enabled = typeof __fast_render_config != 'undefined';\nFastRender.Log = Log;","if(typeof __fast_render_config == 'undefined') {\n  Log('NO_FAST_RENDER');\n  return;\n}\n\nvar revertedBackToOriginal = false;\nvar reconnecting = false;\n\nvar originalLivedataData = Meteor.default_connection._livedata_data;\nMeteor.default_connection._livedata_data = function(msg) {\n  Log('DDP_RECIEVE', msg);\n\n\n  // fast-render adds data manually while initializing\n  // But when the server sends actual data via DDP, it also tries to add\n  // Then we need to detect that and alter\n  //\n  // But we don't need to interfer with Meteor's simulation process\n  // That's why we are checking for serverDocs and ignore manual handling\n  //\n  // We don't need this logic after our special handling reverted back to\n  // original. But we can't detect when null publications completed or not\n  // That's why we need keep this logic\n  //\n  // It's okay to ignore this logic after sometime, but not sure when exactly\n\n  var serverDoc = this._getServerDoc(msg.collection, msg.id);\n  if(!reconnecting && !serverDoc && msg.msg == 'added') {\n    var localCollection = this._mongo_livedata_collections[msg.collection];\n    if(localCollection) {\n      var existingDoc = localCollection.findOne(msg.id);\n      if(existingDoc) {\n        msg.fields = DeepExtend(true, existingDoc, msg.fields);\n        delete msg.fields._id;\n        msg.msg = \"changed\";\n      }\n    }\n  }\n\n  // if we've completed our tasks, no need of special handling\n  if(!revertedBackToOriginal) {\n\n    // This will take care of cleaning special subscription handling\n    // after the actual subscription comes out\n    if(msg.msg == 'ready' && !msg.frGen && __fast_render_config.subscriptions) {\n      msg.subs.forEach(function(subId) {\n        var subscription = __fast_render_config.subscriptionIdMap[subId];\n        if(subscription) {\n          Log('DELETING_SUBSCRIPTION', subscription, subId);\n          // we don't need to handle specially after this\n          delete __fast_render_config.subscriptions[subscription];\n          delete __fast_render_config.subscriptionIdMap[subId];\n\n          // need to track the loaded subscription,\n          // specially for handling in the ironRouter\n          __fast_render_config.loadedSubscriptions[subscription] = true;\n        }\n      });\n    }\n\n    // if all the subscriptions have been processed,\n    // there is no need to keep hijacking\n    if(EJSON.equals(__fast_render_config.subscriptions, {})) {\n      Log('REVERTING_BACK_TO_ORIGINAL_DDP_HANDLING');\n      revertedBackToOriginal = true;\n    }\n  }\n\n  return originalLivedataData.call(this, msg);\n};\n\nvar originalSend = Meteor.default_connection._send;\nMeteor.default_connection._send = function(msg) {\n  Log(\"DDP_SEND\", msg);\n\n  // if looking for connect again to the server, we must need to revert back to\n  // original to prevent some weird DDP issues\n  //  normally it is already reverted, but user may added subscriptions\n  //  in server, which are not subscribed from the client\n  if(msg.msg == 'connect' && msg.session != undefined) {\n    revertedBackToOriginal = true;\n    reconnecting = true;\n  }\n\n  var self = this;\n\n  // if we've completed our tasks, no need of special handling\n  if(!revertedBackToOriginal) {\n    var canSendFakeReady =\n      msg.msg == 'sub' &&\n      __fast_render_config.subscriptions &&\n      __fast_render_config.subscriptions[msg.name];\n\n    if(canSendFakeReady) {\n      Log('FAKE_SUB_READY', msg.name);\n      self._livedata_data({msg:\"ready\",subs:[msg.id], frGen: true});\n      // add the messageId to be handled later\n      __fast_render_config.subscriptionIdMap[msg.id] = msg.name;\n    }\n  }\n\n\n  return originalSend.call(this, msg);\n};\n","__init_fast_render = function(ejsonJson) {\n  // server sends serverRoutePath's encoded to version to prevent XSS\n  // see more: http://goo.gl/UNrfXs\n  var url = __fast_render_config.serverRoutePath;\n  __fast_render_config.serverRoutePath = decodeURI(url);\n\n  var initData = DecodeEJSON(ejsonJson);\n\n  //loading data into the collection\n  for(var collName in initData.collectionData) {\n    var collData = initData.collectionData[collName];\n    collData.forEach(function(itemList) {\n      itemList.forEach(function(item) {\n        var localCollection = Meteor.default_connection._mongo_livedata_collections[collName];\n        if(localCollection) {\n          var exitingDoc = localCollection.findOne(item._id);\n          if(exitingDoc) {\n            DeepExtend(true, exitingDoc, item);\n            localCollection.update(item._id, exitingDoc);\n          } else {\n            localCollection.insert(item);\n          }\n        } else {\n          console.warn('fast-route data found, but no collection exists for: ' + collName);\n        }\n      });\n    });\n  }\n}\n","if(!Package['iron:router']) return;\n\n//track whether inside the ironRouter or not\n//useful for identifying this inside the Meteor.subscribe\nvar insideIronRouter = new Meteor.EnvironmentVariable();\nvar RouteController = FastRender.RouteController = Package['iron:router'].RouteController;\n\n//IR 0.8 comes with method named `_run` instead of `run`\nvar runMethodName = RouteController.prototype._run? \"_run\": \"run\";\nvar originalRun = RouteController.prototype[runMethodName];\nRouteController.prototype[runMethodName] = function() {\n  var self = this;\n  if(FastRender.enabled) {\n    insideIronRouter.withValue(true, function() {\n      originalRun.call(self);\n    });\n  } else {\n    originalRun.call(this);\n  }\n};\n\nvar originalSubscribe = Meteor.subscribe;\nMeteor.subscribe = function(subscription) {\n  var condition =\n    FastRender.enabled &&\n    //need to inside the ironRouter\n    insideIronRouter.get() &&\n    //path loaded from the server and the local Router path should be the same\n    //We can't simply use Router.current().path, it will give some weird deps behaviour\n    //which will result subscriptions stop everytime even they are not meant to\n    getUri() == __fast_render_config.serverRoutePath &&\n    //fast render have been registered to handle this subscription\n    __fast_render_config.subscriptions[subscription] &&\n    //subscription not yet actually loaded (this may call multiple times)\n    !__fast_render_config.loadedSubscriptions[subscription]\n\n  if(condition) {\n    Log('APPLY_IR_SUB_CORRECTIONS', subscription);\n    originalSubscribe.apply(this, arguments);\n\n    //ironRouter call .ready() and and if it's true he think subscription is completed\n    return {\n      ready: function() {\n        return true;\n      }\n    }\n  } else {\n    return originalSubscribe.apply(this, arguments);\n  }\n};\n\nfunction getUri() {\n  var url = document.createElement('a');\n  url.href = location.href;\n\n  var uri = url.pathname;\n  uri += (url.search)? url.search: \"\";\n\n  return uri;\n}\n","if(typeof Meteor.user == 'function') {\n  Tracker.autorun(function() {\n    var user = Meteor.user();\n    var status = Meteor.status();\n\n    //we don't need to clean cookie if we've not connected yet\n    //this is very usefull when testing with connecting a bad ddp connection\n    if(status.connected) {\n      if(user) {\n        var loginToken = Meteor._localStorage.getItem('Meteor.loginToken');\n        var loginTokenExpires = new Date(Meteor._localStorage.getItem('Meteor.loginTokenExpires'));\n\n        Cookie.set('meteor_login_token', loginToken, {\n          path: '/',\n          expires: loginTokenExpires\n        });\n      } else {\n        Cookie.set('meteor_login_token', loginToken, {\n          path: '/',\n          expires: -1\n        });\n      }\n    }\n  });\n} else {\n  //make sure cookie is deleted (if previously setted)\n  Cookie.set('meteor_login_token', loginToken, {\n    path: '/',\n    expires: -1\n  });\n}\n"]}