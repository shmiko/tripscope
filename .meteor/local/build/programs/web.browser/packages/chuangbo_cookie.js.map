)]}'
{"version":3,"file":"/packages/chuangbo:cookie.js","sources":["chuangbo:cookie/cookie.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,Y;;AAEA,oB;;AAEA,a;AACA,oB;AACA,iB;AACA,0E;AACA,kD;;;AAGA,yB;;AAEA,oC;AACA,oC;;;AAGA,O;AACA,mD;AACA,M;AACA,+D;AACA,M;AACA,8E;AACA,4E;AACA,8E;AACA,gF;AACA,6E;AACA,4D;AACA,M;AACA,8E;AACA,8E;AACA,iD;AACA,O;AACA,0C;AACA,iC;;AAEA,4C;AACA,6C;AACA,S;AACA,c;AACA,oC;AACA,S;;AAEA,0E;AACA,0D;AACA,M;;;AAGA,O;AACA,iD;AACA,M;AACA,0D;AACA,M;AACA,wD;AACA,M;AACA,0E;AACA,8D;AACA,kE;AACA,8E;AACA,sD;AACA,M;AACA,kD;AACA,O;AACA,iD;AACA,iC;;AAEA,gC;AACA,yC;AACA,uC;AACA,mC;;AAEA,8B;AACA,0C;AACA,S;;AAEA,sC;;AAEA,kB;AACA,2B;AACA,uC;AACA,8B;AACA,mD;AACA,S;AACA,mC;AACA,sD;AACA,S;;AAEA,iB;AACA,uC;AACA,yC;AACA,S;;AAEA,e;AACA,qC;AACA,qC;AACA,S;;AAEA,iB;AACA,gC;AACA,+B;AACA,S;;AAEA,+B;AACA,oB;AACA,M;;;AAGA,O;AACA,0E;AACA,4B;AACA,M;AACA,6D;AACA,M;AACA,0E;AACA,8D;AACA,0E;AACA,yB;AACA,M;AACA,kD;AACA,O;AACA,6C;AACA,gC;AACA,yC;AACA,2C;AACA,M;;;AAGA,oD;AACA,yB;;AAEA,gD;;AAEA,2D;AACA,iD;AACA,2B;AACA,4B;AACA,gC;;AAEA,qE;;AAEA,mE;AACA,oE;AACA,uD;AACA,yB;AACA,gE;AACA,gE;AACA,2E;AACA,kC;AACA,4D;AACA,gD;AACA,qB;AACA,wB;AACA,4E;AACA,qC;AACA,wD;AACA,qC;AACA,iB;;AAEA,iC;AACA,sD;AACA,iB;AACA,a;;AAEA,S;;AAEA,uB;AACA,K;;;AAGA,c;;AAEA,0B;AACA,qC;AACA,K;;AAEA,kC;AACA,uC;AACA,K;;AAEA,uC;AACA,sC;AACA,0E;AACA,S;AACA,K;;AAEA,sB;AACA,iB;AACA,K;;AAEA,W","sourcesContent":["Cookie = {};\n\n(function(exports) {\n\n    // Cookie\n    // -------------\n    // Thanks to:\n    //  - http://www.nczonline.net/blog/2009/05/05/http-cookies-explained/\n    //  - http://developer.yahoo.com/yui/3/cookie/\n\n\n    var Cookie = exports;\n\n    var decode = decodeURIComponent;\n    var encode = encodeURIComponent;\n\n\n    /**\n     * Returns the cookie value for the given name.\n     *\n     * @param {String} name The name of the cookie to retrieve.\n     *\n     * @param {Function|Object} options (Optional) An object containing one or\n     *     more cookie options: raw (true/false) and converter (a function).\n     *     The converter function is run on the value before returning it. The\n     *     function is not used if the cookie doesn't exist. The function can be\n     *     passed instead of the options object for conveniently. When raw is\n     *     set to true, the cookie value is not URI decoded.\n     *\n     * @return {*} If no converter is specified, returns a string or undefined\n     *     if the cookie doesn't exist. If the converter is specified, returns\n     *     the value returned from the converter.\n     */\n    Cookie.get = function(name, options) {\n        validateCookieName(name);\n\n        if (typeof options === 'function') {\n            options = { converter: options };\n        }\n        else {\n            options = options || {};\n        }\n\n        var cookies = parseCookieString(document.cookie, !options['raw']);\n        return (options.converter || same)(cookies[name]);\n    };\n\n\n    /**\n     * Sets a cookie with a given name and value.\n     *\n     * @param {string} name The name of the cookie to set.\n     *\n     * @param {*} value The value to set for the cookie.\n     *\n     * @param {Object} options (Optional) An object containing one or more\n     *     cookie options: path (a string), domain (a string),\n     *     expires (number or a Date object), secure (true/false),\n     *     and raw (true/false). Setting raw to true indicates that the cookie\n     *     should not be URI encoded before being set.\n     *\n     * @return {string} The created cookie string.\n     */\n    Cookie.set = function(name, value, options) {\n        validateCookieName(name);\n\n        options = options || {};\n        var expires = options['expires'];\n        var domain = options['domain'];\n        var path = options['path'];\n\n        if (!options['raw']) {\n            value = encode(String(value));\n        }\n\n        var text = name + '=' + value;\n\n        // expires\n        var date = expires;\n        if (typeof date === 'number') {\n            date = new Date();\n            date.setDate(date.getDate() + expires);\n        }\n        if (date instanceof Date) {\n            text += '; expires=' + date.toUTCString();\n        }\n\n        // domain\n        if (isNonEmptyString(domain)) {\n            text += '; domain=' + domain;\n        }\n\n        // path\n        if (isNonEmptyString(path)) {\n            text += '; path=' + path;\n        }\n\n        // secure\n        if (options['secure']) {\n            text += '; secure';\n        }\n\n        document.cookie = text;\n        return text;\n    };\n\n\n    /**\n     * Removes a cookie from the machine by setting its expiration date to\n     * sometime in the past.\n     *\n     * @param {string} name The name of the cookie to remove.\n     *\n     * @param {Object} options (Optional) An object containing one or more\n     *     cookie options: path (a string), domain (a string),\n     *     and secure (true/false). The expires option will be overwritten\n     *     by the method.\n     *\n     * @return {string} The created cookie string.\n     */\n    Cookie.remove = function(name, options) {\n        options = options || {};\n        options['expires'] = new Date(0);\n        return this.set(name, '', options);\n    };\n\n\n    function parseCookieString(text, shouldDecode) {\n        var cookies = {};\n\n        if (isString(text) && text.length > 0) {\n\n            var decodeValue = shouldDecode ? decode : same;\n            var cookieParts = text.split(/;\\s/g);\n            var cookieName;\n            var cookieValue;\n            var cookieNameValue;\n\n            for (var i = 0, len = cookieParts.length; i < len; i++) {\n\n                // Check for normally-formatted cookie (name-value)\n                cookieNameValue = cookieParts[i].match(/([^=]+)=/i);\n                if (cookieNameValue instanceof Array) {\n                    try {\n                        cookieName = decode(cookieNameValue[1]);\n                        cookieValue = decodeValue(cookieParts[i]\n                                .substring(cookieNameValue[1].length + 1));\n                    } catch (ex) {\n                        // Intentionally ignore the cookie -\n                        // the encoding is wrong\n                    }\n                } else {\n                    // Means the cookie does not have an \"=\", so treat it as\n                    // a boolean flag\n                    cookieName = decode(cookieParts[i]);\n                    cookieValue = '';\n                }\n\n                if (cookieName) {\n                    cookies[cookieName] = cookieValue;\n                }\n            }\n\n        }\n\n        return cookies;\n    }\n\n\n    // Helpers\n\n    function isString(o) {\n        return typeof o === 'string';\n    }\n\n    function isNonEmptyString(s) {\n        return isString(s) && s !== '';\n    }\n\n    function validateCookieName(name) {\n        if (!isNonEmptyString(name)) {\n            throw new TypeError('Cookie name must be a non-empty string');\n        }\n    }\n\n    function same(s) {\n        return s;\n    }\n\n})(Cookie);\n"]}