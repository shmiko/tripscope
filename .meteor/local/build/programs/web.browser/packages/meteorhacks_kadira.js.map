)]}'
{"version":3,"file":"/packages/meteorhacks:kadira.js","sources":["meteorhacks:kadira/lib/common/unify.js","meteorhacks:kadira/lib/models/base_error.js","meteorhacks:kadira/lib/retry.js","meteorhacks:kadira/lib/ntp.js","meteorhacks:kadira/lib/client/utils.js","meteorhacks:kadira/lib/client/models/error.js","meteorhacks:kadira/lib/client/error_reporters/zone.js","meteorhacks:kadira/lib/client/error_reporters/window_error.js","meteorhacks:kadira/lib/client/error_reporters/meteor_debug.js","meteorhacks:kadira/lib/client/kadira.js","meteorhacks:kadira/lib/profile/client.js","meteorhacks:kadira/lib/common/default_error_filters.js","meteorhacks:kadira/lib/common/send.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,Y;AACA,oB;;AAEA,sB;AACA,uC;AACA,Q;AACA,wC;AACA,C;;AAEA,8C;AACA,8C;AACA,gD;AACA,U;AACA,mC;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;ACfA,oC;AACA,qB;AACA,E;;AAEA,uD;AACA,oC;AACA,+B;AACA,U;AACA,uD;AACA,G;AACA,E;;AAEA,0D;AACA,4C;AACA,kB;AACA,mC;AACA,G;AACA,E;;AAEA,iF;AACA,gD;AACA,mC;AACA,S;AACA,4D;AACA,kC;AACA,kB;AACA,sC;AACA,yC;AACA,kC;AACA,kF;AACA,K;AACA,G;;AAEA,c;AACA,E;;;;;;;;;;;;;;;;;;AClCA,2C;AACA,E;AACA,W;AACA,yD;AACA,kE;AACA,kD;AACA,sD;AACA,mE;AACA,qE;;AAEA,4E;;AAEA,4B;AACA,kB;AACA,qD;AACA,kC;AACA,kB;AACA,oE;AACA,8B;AACA,uC;AACA,mB;AACA,gB;AACA,uB;AACA,M;AACA,yB;AACA,E;;AAEA,2B;;AAEA,mC;AACA,sB;AACA,oB;AACA,uB;AACA,oC;AACA,2B;AACA,I;;AAEA,sE;AACA,oC;AACA,8B;AACA,oB;;AAEA,6B;AACA,6B;;AAEA,2B;AACA,sB;AACA,yD;AACA,kE;AACA,wB;AACA,0D;AACA,4C;AACA,8B;AACA,I;;AAEA,0E;AACA,oC;AACA,oB;AACA,uC;AACA,uB;AACA,oC;;AAEA,8C;AACA,mB;AACA,G;;AAEA,G;;;;;;;;;;;;;;;;;;;AClEA,yB;;AAEA,2B;AACA,6B;AACA,gB;AACA,sB;AACA,uB;AACA,2B;AACA,yB;AACA,2B;AACA,e;AACA,K;AACA,C;;AAEA,uB;AACA,uB;AACA,8B;AACA,e;AACA,kC;AACA,4E;AACA,+D;AACA,yB;AACA,U;AACA,4C;AACA,kC;AACA,G;AACA,E;;AAEA,gD;AACA,+C;AACA,E;;AAEA,oC;AACA,4C;AACA,E;;AAEA,8C;AACA,0C;AACA,E;;AAEA,iC;AACA,sB;AACA,kB;AACA,qB;AACA,yB;AACA,yB;AACA,wB;AACA,gB;AACA,iB;AACA,K;AACA,a;;AAEA,wB;AACA,sB;AACA,0D;AACA,sE;AACA,+C;AACA,Y;AACA,wC;AACA,8D;AACA,4C;AACA,oC;AACA,S;AACA,K;AACA,G;;AAEA,4D;AACA,gC;AACA,wB;AACA,sC;AACA,gB;AACA,4B;AACA,c;AACA,mB;AACA,O;AACA,O;AACA,G;;AAEA,iC;AACA,2C;AACA,kD;AACA,8B;AACA,oE;AACA,wE;AACA,2B;AACA,6C;AACA,gE;AACA,8C;AACA,sC;AACA,W;AACA,6D;AACA,c;AACA,mB;AACA,O;AACA,O;AACA,G;AACA,C;;AAEA,kD;AACA,kB;;AAEA,uB;AACA,sC;AACA,0B;AACA,mD;AACA,iB;AACA,wB;AACA,gB;AACA,gD;AACA,qC;AACA,S;AACA,S;AACA,a;AACA,U;AACA,Y;AACA,kB;AACA,yB;AACA,qC;AACA,6C;AACA,Q;AACA,4B;AACA,sB;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,sB;AACA,uB;AACA,8C;AACA,U;AACA,8B;AACA,wB;AACA,2D;AACA,0C;;AAEA,wB;AACA,qB;AACA,4C;AACA,iC;AACA,S;AACA,8C;AACA,O;AACA,K;AACA,G;AACA,C;;;;;;;;;;;;;;;;;;;ACjJA,8B;AACA,U;AACA,wC;AACA,6C;AACA,uB;AACA,+B;AACA,I;AACA,C;;AAEA,6B;AACA,+C;AACA,wD;AACA,sB;AACA,G;AACA,C;;AAEA,2C;AACA,iB;AACA,qC;AACA,mC;;AAEA,c;AACA,+B;AACA,kC;AACA,K;;AAEA,gB;AACA,0B;AACA,qD;AACA,4D;AACA,gC;AACA,qB;AACA,6B;AACA,wC;AACA,O;;AAEA,qC;AACA,gD;AACA,mG;AACA,mE;AACA,4E;;AAEA,iB;AACA,qE;AACA,iE;AACA,qE;;AAEA,6C;;AAEA,kB;AACA,kC;AACA,qB;AACA,qB;AACA,0B;AACA,6B;AACA,uB;AACA,mB;AACA,uB;AACA,S;AACA,yB;;AAEA,iC;AACA,Y;AACA,sB;AACA,K;AACA,G;AACA,C;;AAEA,gC;AACA,mD;AACA,sB;AACA,iB;AACA,I;AACA,C;;AAEA,uB;AACA,mC;AACA,uC;AACA,U;AACA,kC;AACA,G;AACA,C;;AAEA,iD;AACA,wB;AACA,uC;AACA,yB;AACA,2B;AACA,W;AACA,qD;AACA,oD;AACA,uE;AACA,gB;AACA,2B;AACA,S;AACA,mB;AACA,mD;AACA,O;AACA,K;AACA,e;AACA,G;AACA,C;;AAEA,G;AACA,yE;AACA,mD;AACA,uE;AACA,G;AACA,sC;AACA,8B;AACA,iC;AACA,c;AACA,4C;AACA,yC;AACA,oC;AACA,6C;;AAEA,oC;AACA,4D;AACA,mE;AACA,W;;AAEA,qC;AACA,0B;AACA,W;;AAEA,gC;AACA,yB;AACA,S;AACA,Q;AACA,O;AACA,G;;AAEA,yC;AACA,qE;AACA,sD;AACA,G;AACA,C;;;;;;;;;;;;;;;;;;;ACzIA,gC;AACA,4B;AACA,0B;AACA,oE;AACA,+E;AACA,uE;AACA,kB;;AAEA,yB;;AAEA,iE;AACA,2B;AACA,uB;AACA,wD;AACA,6B;AACA,wB;AACA,oC;AACA,E;;AAEA,yD;;AAEA,iE;AACA,kB;AACA,0E;AACA,W;AACA,I;;AAEA,6B;AACA,4D;AACA,W;AACA,G;;AAEA,a;AACA,gB;AACA,U;AACA,8E;AACA,kB;AACA,Y;AACA,sE;AACA,K;AACA,G;;AAEA,6B;AACA,wC;AACA,G;;AAEA,wB;AACA,yC;AACA,kC;AACA,8B;AACA,4E;AACA,O;AACA,yB;AACA,mD;;AAEA,yD;AACA,+C;AACA,6B;AACA,Y;AACA,+C;AACA,K;AACA,G;AACA,E;;AAEA,gD;AACA,kB;AACA,yC;AACA,6C;AACA,2B;AACA,K;;AAEA,yB;AACA,6C;AACA,G;AACA,uB;AACA,E;;AAEA,qD;AACA,iC;AACA,E;;AAEA,4D;AACA,oC;AACA,a;AACA,kB;AACA,G;AACA,E;;AAEA,iD;AACA,kE;AACA,E;;AAEA,yC;AACA,4C;AACA,E;;;;;;;;;;;;;;;;;;;AC9FA,gC;AACA,mD;AACA,C;;AAEA,mC;AACA,4C;AACA,2C;AACA,W;AACA,G;;AAEA,uE;AACA,8C;AACA,kD;AACA,4C;AACA,0C;AACA,+B;AACA,qC;AACA,yB;AACA,wB;AACA,+B;AACA,yB;AACA,gC;AACA,wC;AACA,S;AACA,O;AACA,G;AACA,C;;;;;;;;;;;;;;;;;;;AC1BA,6D;;AAEA,2D;AACA,4C;AACA,2C;AACA,6D;AACA,G;;AAEA,6B;AACA,mB;AACA,iB;;AAEA,a;AACA,4B;AACA,U;AACA,2E;AACA,G;;AAEA,mC;AACA,2B;AACA,iC;AACA,mB;AACA,oB;AACA,oB;AACA,+B;AACA,4B;AACA,mE;AACA,K;;AAEA,4D;AACA,C;;;;;;;;;;;;;;;;;;;AC9BA,wC;;AAEA,0C;AACA,4C;AACA,2C;AACA,+C;AACA,G;;AAEA,oE;AACA,mB;AACA,+C;AACA,G;;AAEA,oD;AACA,gC;AACA,0B;AACA,6B;AACA,gE;AACA,yC;AACA,iC;AACA,G;;AAEA,2E;AACA,mD;AACA,sC;AACA,yC;AACA,iC;AACA,G;;AAEA,mC;AACA,2B;AACA,iC;AACA,mB;AACA,oB;AACA,oB;AACA,8B;AACA,4B;AACA,mE;AACA,K;;AAEA,oD;AACA,E;;AAEA,iC;AACA,wC;AACA,oD;AACA,mB;AACA,Y;AACA,2C;AACA,yB;AACA,G;AACA,0B;AACA,C;;AAEA,8B;AACA,gC;AACA,C;;;;;;;;;;;;;;;;;;;ACxDA,0C;AACA,4C;AACA,E;;AAEA,2C;AACA,6C;AACA,E;;AAEA,uD;AACA,6D;AACA,qC;AACA,4B;AACA,yD;AACA,6B;AACA,mC;AACA,qB;AACA,wB;AACA,sB;AACA,kB;AACA,gC;AACA,8B;AACA,8E;AACA,O;AACA,G;AACA,E;;AAEA,sE;AACA,wE;AACA,kC;AACA,gC;AACA,6C;AACA,8C;AACA,yB;AACA,G;;AAEA,uE;AACA,+D;AACA,sB;AACA,oE;AACA,iE;AACA,Q;AACA,+C;AACA,C;;AAEA,+B;AACA,iC;AACA,8B;AACA,+B;AACA,6B;AACA,4B;AACA,+B;AACA,K;;AAEA,uD;AACA,mD;AACA,2D;AACA,4B;AACA,gC;AACA,mE;AACA,kE;AACA,6B;AACA,iC;AACA,e;AACA,O;AACA,G;;AAEA,8D;AACA,iC;AACA,G;;AAEA,kC;AACA,4D;AACA,G;AACA,C;;AAEA,8D;AACA,2B;AACA,2B;AACA,C;;;;;;;;;;;;;;;;;;;AC9EA,gD;AACA,uE;AACA,yE;AACA,a;AACA,4E;AACA,Y;AACA,oC;AACA,K;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;ACTA,wB;AACA,sD;AACA,uB;AACA,E;;AAEA,uB;AACA,wD;AACA,4C;AACA,mB;AACA,Y;AACA,kB;AACA,K;AACA,I;;AAEA,qD;AACA,qD;AACA,wC;AACA,gC;AACA,qB;AACA,O;AACA,K;AACA,gB;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;ACvBA,kD;AACA,0B;AACA,uF;AACA,G;;AAEA,uD;AACA,gD;AACA,qB;AACA,yB;AACA,gB;AACA,kB;AACA,wB;AACA,wB;AACA,K;;AAEA,+C;AACA,c;;AAEA,2B;AACA,wB;AACA,2C;AACA,Y;AACA,kE;AACA,iC;AACA,K;AACA,G;;AAEA,mB;AACA,wE;AACA,e;AACA,uB;AACA,mC;AACA,6C;AACA,c;AACA,qE;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,sC;AACA,oE;AACA,E;;AAEA,6D;AACA,U;AACA,iB;AACA,kB;AACA,oC;AACA,kC;AACA,0B;AACA,oB;AACA,M;AACA,6B;AACA,gC;AACA,K;AACA,M;AACA,C;;AAEA,6D;AACA,uC;AACA,oC;AACA,wB;AACA,uB;AACA,oB;AACA,yC;AACA,M;;AAEA,iE;AACA,e;AACA,sE;AACA,gD;AACA,c;AACA,sB;AACA,S;AACA,O;AACA,W;AACA,C","sourcesContent":["Kadira = {};\nKadira.options = {};\n\nif(Meteor.wrapAsync) {\n  Kadira._wrapAsync = Meteor.wrapAsync;\n} else {\n  Kadira._wrapAsync = Meteor._wrapAsync;\n}\n\nKadira._binaryRequire = function(moduleName) {\n  if(typeof KadiraBinaryDeps != 'undefined') {\n    return KadiraBinaryDeps.require(moduleName);\n  } else {\n    return Npm.require(moduleName);\n  }\n};","BaseErrorModel = function(options) {\n  this._filters = [];\n};\n\nBaseErrorModel.prototype.addFilter = function(filter) {\n  if(typeof filter === 'function') {\n    this._filters.push(filter);\n  } else {\n    throw new Error(\"Error filter must be a function\");\n  }\n};\n\nBaseErrorModel.prototype.removeFilter = function(filter) {\n  var index = this._filters.indexOf(filter);\n  if(index >= 0) {\n    this._filters.splice(index, 1);\n  }\n};\n\nBaseErrorModel.prototype.applyFilters = function(type, message, error, subType) {\n  for(var lc=0; lc<this._filters.length; lc++) {\n    var filter = this._filters[lc];\n    try {\n      var validated = filter(type, message, error, subType);\n      if(!validated) return false;\n    } catch (ex) {\n      // we need to remove this filter\n      // we may ended up in a error cycle\n      this._filters.splice(lc, 1);\n      throw new Error(\"an error thrown from a filter you've suplied\", ex.message);\n    }\n  }\n\n  return true;\n};","// Retry logic with an exponential backoff.\n//\n// options:\n//  baseTimeout: time for initial reconnect attempt (ms).\n//  exponent: exponential factor to increase timeout each attempt.\n//  maxTimeout: maximum time between retries (ms).\n//  minCount: how many times to reconnect \"instantly\".\n//  minTimeout: time to wait for the first `minCount` retries (ms).\n//  fuzz: factor to randomize retry times by (to avoid retry storms).\n\n//TODO: remove this class and use Meteor Retry in a later version of meteor.\n\nRetry = function (options) {\n  var self = this;\n  _.extend(self, _.defaults(_.clone(options || {}), {\n    baseTimeout: 1000, // 1 second\n    exponent: 2.2,\n    // The default is high-ish to ensure a server can recover from a\n    // failure caused by load.\n    maxTimeout: 5 * 60000, // 5 minutes\n    minTimeout: 10,\n    minCount: 2,\n    fuzz: 0.5 // +- 25%\n  }));\n  self.retryTimer = null;\n};\n\n_.extend(Retry.prototype, {\n\n  // Reset a pending retry, if any.\n  clear: function () {\n    var self = this;\n    if(self.retryTimer)\n      clearTimeout(self.retryTimer);\n    self.retryTimer = null;\n  },\n\n  // Calculate how long to wait in milliseconds to retry, based on the\n  // `count` of which retry this is.\n  _timeout: function (count) {\n    var self = this;\n\n    if(count < self.minCount)\n      return self.minTimeout;\n\n    var timeout = Math.min(\n      self.maxTimeout,\n      self.baseTimeout * Math.pow(self.exponent, count));\n    // fuzz the timeout randomly, to avoid reconnect storms when a\n    // server goes down.\n    timeout = timeout * ((Random.fraction() * self.fuzz) +\n                         (1 - self.fuzz/2));\n    return Math.ceil(timeout);\n  },\n\n  // Call `fn` after a delay, based on the `count` of which retry this is.\n  retryLater: function (count, fn) {\n    var self = this;\n    var timeout = self._timeout(count);\n    if(self.retryTimer)\n      clearTimeout(self.retryTimer);\n\n    self.retryTimer = setTimeout(fn, timeout);\n    return timeout;\n  }\n\n});\n","var logger = getLogger();\n\nNtp = function (endpoint) {\n  this.setEndpoint(endpoint);\n  this.diff = 0;\n  this.synced = false;\n  this.reSyncCount = 0;\n  this.reSync = new Retry({\n    baseTimeout: 1000*60,\n    maxTimeout: 1000*60*10,\n    minCount: 0\n  });\n}\n\nNtp._now = function() {\n  var now = Date.now();\n  if(typeof now == 'number') {\n    return now;\n  } else if(now instanceof Date) {\n    // some extenal JS libraries override Date.now and returns a Date object\n    // which directly affect us. So we need to prepare for that\n    return now.getTime();\n  } else {\n    // trust me. I've seen now === undefined\n    return (new Date()).getTime();\n  }\n};\n\nNtp.prototype.setEndpoint = function(endpoint) {\n  this.endpoint = endpoint + '/simplentp/sync';\n};\n\nNtp.prototype.getTime = function() {\n  return Ntp._now() + Math.round(this.diff);\n};\n\nNtp.prototype.syncTime = function(localTime) {\n  return localTime + Math.ceil(this.diff);\n};\n\nNtp.prototype.sync = function() {\n  logger('init sync');\n  var self = this;\n  var retryCount = 0;\n  var retry = new Retry({\n    baseTimeout: 1000*20,\n    maxTimeout: 1000*60,\n    minCount: 1,\n    minTimeout: 0\n  });\n  syncTime();\n\n  function syncTime () {\n    if(retryCount<5) {\n      logger('attempt time sync with server', retryCount);\n      // if we send 0 to the retryLater, cacheDns will run immediately\n      retry.retryLater(retryCount++, cacheDns);\n    } else {\n      logger('maximum retries reached');\n      self.reSync.retryLater(self.reSyncCount++, function () {\n        var args = [].slice.call(arguments);\n        self.sync.apply(self, args);\n      });\n    }\n  }\n\n  // first attempt is to cache dns. So, calculation does not\n  // include DNS resolution time\n  function cacheDns () {\n    self.getServerTime(function(err) {\n      if(!err) {\n        calculateTimeDiff();\n      } else {\n        syncTime();\n      }\n    });\n  }\n\n  function calculateTimeDiff () {\n    var startTime = (new Date()).getTime();\n    self.getServerTime(function(err, serverTime) {\n      if(!err && serverTime) {\n        // (Date.now() + startTime)/2 : Midpoint between req and res\n        self.diff = serverTime - ((new Date()).getTime() + startTime)/2;\n        self.synced = true;\n        // we need to send 1 into retryLater.\n        self.reSync.retryLater(self.reSyncCount++, function () {\n          var args = [].slice.call(arguments);\n          self.sync.apply(self, args);\n        });\n        logger('successfully updated diff value', self.diff);\n      } else {\n        syncTime();\n      }\n    });\n  }\n}\n\nNtp.prototype.getServerTime = function(callback) {\n  var self = this;\n\n  if(Meteor.isServer) {\n    var Fiber = Npm.require('fibers');\n    new Fiber(function() {\n      HTTP.get(self.endpoint, function (err, res) {\n        if(err) {\n          callback(err);\n        } else {\n          var serverTime = parseInt(res.content)\n          callback(null, serverTime);\n        }\n      });\n    }).run();\n  } else {\n    $.ajax({\n      type: 'GET',\n      url: self.endpoint,\n      success: function(serverTime) {\n        callback(null, parseInt(serverTime));\n      },\n      error: function(err) {\n        callback(err);\n      }\n    });\n  }\n};\n\nfunction getLogger() {\n  if(Meteor.isServer) {\n    return Npm.require('debug')(\"kadira:ntp\");\n  } else {\n    return function(message) {\n      var canLogKadira =\n        Meteor._localStorage.getItem('LOG_KADIRA') !== null\n        && typeof console !== 'undefined';\n\n      if(canLogKadira) {\n        if(message) {\n          message = \"kadira:ntp \" + message;\n          arguments[0] = message;\n        }\n        console.log.apply(console, arguments);\n      }\n    }\n  }\n}\n","getBrowserInfo = function () {\n  return {\n    browser: window.navigator.userAgent,\n    userId: Meteor.userId && Meteor.userId(),\n    url: location.href,\n    resolution: getResolution()\n  };\n}\n\ngetResolution = function () {\n  if(screen && screen.width && screen.height) {\n    var resolution = screen.width + 'x' + screen.height;\n    return resolution;\n  }\n}\n\ngetErrorStack = function (zone, callback) {\n  var trace = [];\n  var eventMap = zone.eventMap || {};\n  var infoMap = zone.infoMap || {};\n\n  trace.push({\n    at: (new Date().getTime()),\n    stack: zone.erroredStack.get()\n  });\n\n  processZone();\n  function processZone() {\n    // we assume, first two zones are not interesting\n    // bacause, they are some internal meteor loading stuffs\n    if(zone && zone.depth > 2) {\n      var stack = \"\";\n      if(zone.currentStack) {\n        stack = zone.currentStack.get();\n      }\n\n      var events = eventMap[zone.id];\n      var info = getInfoArray(infoMap[zone.id]);\n      var ownerArgsEvent = events && events[0] && events[0].type == 'owner-args' && events.shift();\n      var runAt = (ownerArgsEvent)? ownerArgsEvent.at : zone.runAt;\n      var ownerArgs = (ownerArgsEvent)? _.toArray(ownerArgsEvent.args) : [];\n\n      // limiting\n      events = _.map(_.last(events, 5), checkSizeAndPickFields(100));\n      info = _.map(_.last(info, 5), checkSizeAndPickFields(100));\n      ownerArgs = checkSizeAndPickFields(200)(_.first(ownerArgs, 5));\n\n      zone.owner && delete zone.owner.zoneId;\n\n      trace.push({\n        createdAt: zone.createdAt,\n        runAt: runAt,\n        stack: stack,\n        owner: zone.owner,\n        ownerArgs: ownerArgs,\n        events: events,\n        info: info,\n        zoneId: zone.id\n      });\n      zone = zone.parent;\n\n      setTimeout(processZone, 0);\n    } else {\n      callback(trace);\n    }\n  }\n}\n\ngetInfoArray = function (info) {\n  return _(info || {}).map(function (value, type) {\n    value.type = type;\n    return value;\n  })\n}\n\ngetTime = function () {\n  if(Kadira && Kadira.syncedDate) {\n    return Kadira.syncedDate.getTime();\n  } else {\n    return (new Date().getTime());\n  }\n}\n\ncheckSizeAndPickFields = function(maxFieldSize) {\n  return function(obj) {\n    maxFieldSize = maxFieldSize || 100;\n    for(var key in obj) {\n      var value = obj[key];\n      try {\n        var valueStringified = JSON.stringify(value);\n        if(valueStringified.length > maxFieldSize) {\n          obj[key] = valueStringified.substr(0, maxFieldSize) + \" ...\";\n        } else {\n          obj[key] = value;\n        }\n      } catch(ex) {\n        obj[key] = 'Error: cannot stringify value';\n      }\n    }\n    return obj;\n  }\n}\n\n/**\n * IE8 and IE9 does not support CORS with the usual XMLHttpRequest object\n * If XDomainRequest exists, use it to send errors.\n * XDR can POST data to HTTPS endpoints only if current page uses HTTPS\n */\nfixInternetExplorerXDR = function () {\n  if (window.XDomainRequest) {\n    $.ajaxTransport(function(s) {\n      return {\n        send: function (headers, callback) {\n          var xdr = new XDomainRequest();\n          var data = s.data || null;\n          var url = matchPageProtocol(s.url);\n\n          xdr.onload = function () {\n            var headers = {'Content-Type': xdr.contentType};\n            callback(200, 'OK', {text: xdr.responseText}, headers);\n          }\n\n          xdr.onerror = function () {\n            callback(404);\n          }\n\n          xdr.open(s.type, url);\n          xdr.send(data);\n        }\n      };\n    });\n  }\n\n  function matchPageProtocol (endpoint) {\n    var withoutProtocol = endpoint.substr(endpoint.indexOf(':') + 1);\n    return window.location.protocol + withoutProtocol;\n  }\n}\n","ErrorModel = function(options) {\n  BaseErrorModel.call(this);\n  options = options || {};\n  options.maxErrorsPerInterval = options.maxErrorsPerInterval || 10;\n  options.intervalInMillis = options.intervalInMillis || 1000 * 60 *2; //2 mins\n  options.waitForNtpSyncInterval = options.waitForNtpSyncInterval || 0;\n  var self = this;\n\n  self.options = options;\n\n  // errorsSentCount will be reseted at the start of the interval\n  self.errorsSentCount = 0;\n  self.errorsSent = {};\n  self.intervalTimeoutHandler = setInterval(function() {\n    self.errorsSentCount = 0;\n    self._flushErrors();\n  }, self.options.intervalInMillis);\n};\n\n_.extend(ErrorModel.prototype, BaseErrorModel.prototype);\n\nErrorModel.prototype.sendError = function(errorDef, err, force) {\n  var self = this;\n  if(!this.applyFilters('client', errorDef.name, err, errorDef.subType)) {\n    return;\n  };\n\n  if(!this.canSendErrors()) {\n    // reached maximum error count for this interval (1 min)\n    return;\n  }\n\n  if(force) {\n    sendError();\n  } else {\n    if(Kadira.syncedDate.synced || self.options.waitForNtpSyncInterval == 0) {\n      sendError();\n    } else {\n      setTimeout(forceSendError, self.options.waitForNtpSyncInterval);\n    }\n  }\n\n  function forceSendError() {\n    self.sendError(errorDef, err, true);\n  }\n\n  function sendError() {\n    if(!self.errorsSent[errorDef.name]) {\n      // sync time with the server\n      if(errorDef.startTime) {\n        errorDef.startTime = Kadira.syncedDate.syncTime(errorDef.startTime);\n      }\n      errorDef.count = 1;\n      Kadira.send({errors: [errorDef]}, '/errors');\n\n      self.errorsSent[errorDef.name] = _.clone(errorDef);\n      self.errorsSent[errorDef.name].count = 0;\n      self.errorsSentCount++;\n    } else {\n      self.increamentErrorCount(errorDef.name);\n    }\n  }\n};\n\nErrorModel.prototype._flushErrors = function() {\n  var self = this;\n  var errors = _.values(self.errorsSent);\n  errors = _.filter(errors, function(error) {\n    return error.count > 0;\n  });\n\n  if(errors.length > 0) {\n    Kadira.send({errors: errors}, '/errors');\n  }\n  self.errorsSent = {};\n};\n\nErrorModel.prototype.isErrorExists = function(name) {\n  return !!this.errorsSent[name];\n};\n\nErrorModel.prototype.increamentErrorCount = function(name) {\n  var error = this.errorsSent[name];\n  if(error) {\n    error.count++;\n  }\n};\n\nErrorModel.prototype.canSendErrors = function() {\n  return this.errorsSentCount < this.options.maxErrorsPerInterval;\n};\n\nErrorModel.prototype.close = function() {\n  clearTimeout(this.intervalTimeoutHandler);\n};\n","if(window.Zone && Zone.inited) {\n  Zone.Reporters.add('kadira', kadiraZoneReporter);\n}\n\nfunction kadiraZoneReporter(zone) {\n  // track only if error tracking is enabled\n  if(!Kadira.options.enableErrorTracking) {\n    return;\n  }\n\n  var errorName = Zone.Reporters.getErrorMessage(zone.erroredStack._e);\n  if(Kadira.errors.isErrorExists(errorName)) {\n    Kadira.errors.increamentErrorCount(errorName);\n  } else if(Kadira.errors.canSendErrors()) {\n    getErrorStack(zone, function(stacks) {\n      Kadira.errors.sendError({\n        appId : Kadira.options.appId,\n        name : errorName,\n        type : 'client',\n        startTime : zone.runAt,\n        subType : 'zone',\n        info : getBrowserInfo(),\n        stacks : JSON.stringify(stacks),\n      });\n    });\n  }\n}\n","var prevWindowOnError = window.onerror || Function.prototype;\n\nwindow.onerror = function(message, url, line, col, error) {\n  // track only if error tracking is enabled\n  if(!Kadira.options.enableErrorTracking) {\n    return prevWindowOnError(message, url, line, col, error);\n  }\n\n  url = url || '<anonymous>';\n  line = line || 0;\n  col = col || 0;\n\n  if(error) {\n    var stack = error.stack;\n  } else {\n    var stack = 'Error:\\n    at window.onerror ('+url+':'+line+':'+col+')';\n  }\n\n  var now = (new Date().getTime());\n  Kadira.errors.sendError({\n    appId : Kadira.options.appId,\n    name : message,\n    type : 'client',\n    startTime : now,\n    subType : 'window.onerror',\n    info : getBrowserInfo(),\n    stacks : JSON.stringify([{at: now, events: [], stack: stack}]),\n  });\n\n  return prevWindowOnError(message, url, line, col, error);;\n}\n","var originalMeteorDebug = Meteor._debug;\n\nMeteor._debug = function(message, stack) {\n  // track only if error tracking is enabled\n  if(!Kadira.options.enableErrorTracking) {\n    return originalMeteorDebug(message, stack);\n  }\n\n  // do not track if a zone is available (let zone handle the error)\n  if(window.zone) {\n    return originalMeteorDebug(message, stack);\n  }\n\n  // We hate Meteor._debug (no single usage pattern)\n  if(message instanceof Error) {\n    stack = message.stack;\n    message = message.message\n  } else if(typeof message == 'string' && stack === undefined) {\n    stack = getStackFromMessage(message);\n    message = firstLine(message);\n  }\n\n  // sometimes Meteor._debug is called with the stack concat to the message\n  // FIXME Meteor._debug can be called in many ways\n  if(message && stack === undefined) {\n    stack = getStackFromMessage(message);\n    message = firstLine(message);\n  }\n\n  var now = (new Date().getTime());\n  Kadira.errors.sendError({\n    appId : Kadira.options.appId,\n    name : message,\n    type : 'client',\n    startTime : now,\n    subType : 'meteor._debug',\n    info : getBrowserInfo(),\n    stacks : JSON.stringify([{at: now, events: [], stack: stack}]),\n  });\n\n  return originalMeteorDebug.apply(this, arguments);\n};\n\nvar stackRegex = /^\\s+at\\s.+$/gm;\nfunction getStackFromMessage (message) {\n  // add empty string to add the empty line at start\n  var stack = [''];\n  var match;\n  while(match = stackRegex.exec(message)) {\n    stack.push(match[0]);\n  }\n  return stack.join('\\n');\n}\n\nfunction firstLine (message) {\n  return message.split('\\n')[0];\n}\n","Kadira.enableErrorTracking = function () {\n  Kadira.options.enableErrorTracking = true;\n};\n\nKadira.disableErrorTracking = function () {\n  Kadira.options.enableErrorTracking = false;\n};\n\nKadira.trackError = function (type, message, options) {\n  if(Kadira.options.enableErrorTracking && type && message) {\n    var now = (new Date()).getTime();\n    options = options || {};\n    _.defaults(options, {subType: 'client', stacks: ''});\n    Kadira.errors.sendError({\n      appId : Kadira.options.appId,\n      name : message,\n      source : 'client',\n      startTime : now,\n      type : type,\n      subType : options.subType,\n      info : getBrowserInfo(),\n      stacks : JSON.stringify([{at: now, events: [], stack: options.stacks}]),\n    });\n  }\n};\n\n// Create new NTP object and error model immediately so it can be used\n// endpoints is set later using __meteor_runtime_config__ or publication\nKadira.syncedDate = new Ntp(null);\nKadira.errors = new ErrorModel({\n  waitForNtpSyncInterval: 1000 * 5, // 5 secs\n  intervalInMillis: 1000 * 60 * 1, // 1minutes\n  maxErrorsPerInterval: 5\n});\n\n// __meteor_runtime_config__ cannot be dynamically set for cordova apps\n// using a null subscription to send required options to client\nif(Meteor.isCordova) {\n  var SettingsCollection = new Meteor.Collection('kadira_settings');\n  SettingsCollection.find().observe({added: _.once(initialize)});\n} else {\n  initialize(__meteor_runtime_config__.kadira);\n}\n\nfunction initialize (options) {\n  Kadira.options = options || {};\n  _.defaults(Kadira.options, {\n    errorDumpInterval: 1000*60,\n    maxErrorsPerInterval: 10,\n    collectAllStacks: false,\n    enableErrorTracking: false,\n  });\n\n  if(Kadira.options.appId && Kadira.options.endpoint) {\n    // update endpoint after receiving correct data\n    Kadira.syncedDate.setEndpoint(Kadira.options.endpoint);\n    Kadira.connected = true;\n    Meteor.startup(function () {\n      // if we don't do this this might block the initial rendering\n      // or, it will show up bottom of the page, which is not cool\n      setTimeout(function() {\n        Kadira.syncedDate.sync();\n      }, 5000);\n    });\n  }\n\n  if(Kadira.connected && Kadira.options.enableErrorTracking) {\n    Kadira.enableErrorTracking();\n  }\n\n  if(window.Zone && Zone.inited) {\n    Zone.collectAllStacks = Kadira.options.collectAllStacks;\n  }\n}\n\n// patch jQuery ajax transport to use IE8/IE9 XDR if necessary\nif(window.XDomainRequest) {\n  fixInternetExplorerXDR();\n}\n","Kadira.profileCpu = function(arg1, arg2, type) {\n  console.log(\"Kadira: profiling has been started. check server logs\");\n  Meteor.call('kadira.profileCpu', arg1, arg2, type, function(err, res) {\n    if(err) {\n      console.error(\"Kadira: profiling CPU attempt failed: \" + err.message);\n    } else {\n      console.log(\"Kadira: \" + res);\n    }\n  });\n};","var commonErrRegExps = [\n  /connection timeout\\. no (\\w*) heartbeat received/i,\n  /INVALID_STATE_ERR/i,\n];\n\nKadira.errorFilters = {\n  filterValidationErrors: function(type, message, err) {\n    if(err && err instanceof Meteor.Error) {\n      return false;\n    } else {\n      return true;\n    }\n  },\n\n  filterCommonMeteorErrors: function(type, message) {\n    for(var lc=0; lc<commonErrRegExps.length; lc++) {\n      var regExp = commonErrRegExps[lc];\n      if(regExp.test(message)) {\n        return false;\n      }\n    }\n    return true;\n  }\n};","Kadira.send = function (payload, path, callback) {\n  if(!Kadira.connected)  {\n    throw new Error(\"You need to connect with Kadira first, before sending messages!\");\n  }\n\n  path = (path.substr(0, 1) != '/')? \"/\" + path : path;\n  var endpoint = Kadira.options.endpoint + path;\n  var retryCount = 0;\n  var retry = new Retry({\n    minCount: 1,\n    minTimeout: 0,\n    baseTimeout: 1000*5,\n    maxTimeout: 1000*60,\n  });\n\n  var sendFunction = Kadira._getSendFunction();\n  tryToSend();\n\n  function tryToSend(err) {\n    if(retryCount < 5) {\n      retry.retryLater(retryCount++, send);\n    } else {\n      console.warn('Error sending error traces to kadira server');\n      if(callback) callback(err);\n    }\n  }\n\n  function send() {\n    sendFunction(endpoint, payload, function(err, content, statusCode) {\n      if(err) {\n        tryToSend(err);\n      } else if(statusCode == 200){\n        if(callback) callback(null, content);\n      } else {\n        if(callback) callback(new Meteor.Error(statusCode, content));\n      }\n    });\n  }\n};\n\nKadira._getSendFunction = function() {\n  return (Meteor.isServer)? Kadira._serverSend : Kadira._clientSend;\n};\n\nKadira._clientSend = function (endpoint, payload, callback) {\n  $.ajax({\n    type: 'POST',\n    url: endpoint,\n    contentType: 'application/json',\n    data: JSON.stringify(payload),\n    error: function(err) {\n      callback(err);\n    },\n    success: function(data) {\n      callback(null, data, 200);\n    }\n  }); \n}\n\nKadira._serverSend = function (endpoint, payload, callback) {\n  callback = callback || function() {};\n  var Fiber = Npm.require('fibers');\n  new Fiber(function() {\n    var httpOptions = {\n      data: payload,\n      headers: Kadira.options.authHeaders\n    };\n\n    HTTP.call('POST', endpoint, httpOptions, function(err, res) {\n      if(res) {\n        var content = (res.statusCode == 200)? res.data : res.content;\n        callback(null, content, res.statusCode);\n      } else {\n        callback(err);\n      }  \n    });\n  }).run();\n}"]}